package main

import (
	"bytes"
	"flag"
	"fmt"
	"generator/common"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	gStructName = flag.String("type", "", "struct type name")
	gTagName    = flag.String("tag", "bson", "tag name")
	gPath       = flag.String("path", "./", "file path")
	gDebug      = flag.Bool("debug", false, "show generated data")
)

const (
	gSuffix = "_column" + common.AutoGeneratedSuffix
	temp    = `
package {{.PackageName}}

type _{{.StructName}}Column struct {
{{range $key, $value := .Columns}} {{ $key }} string 
{{end}}
}

var {{.StructName}}Columns  _{{.StructName}}Column

func init() {
{{range $key, $value := .Columns}} {{ $.StructName}}Columns.{{$key}} = "{{$value}}" 
{{end -}}
}
`
)

// TempData 表示生成template所需要的数据结构
type TempData struct {
	FileName    string
	PackageName string
	StructName  string
	Columns     map[string]string
}

func main() {
	log.SetFlags(log.Lshortfile | log.Ltime)
	flag.Parse()
	if len(*gStructName) == 0 {
		flag.Usage()
		log.Fatal("struct type must be set")
	}

	common.WalkPathWithGoExt(*gPath, handleFile)
}

func handleFile(filename string) error {
	var tempData TempData
	tempData.Columns = make(map[string]string)

	pkg, err := common.GetPackageFromFile(filename)
	if err != nil {
		panic(err)
	}

	if len(pkg.Structs) == 0 {
		return nil
	}

	var target *common.Struct
	for _, sct := range pkg.Structs {
		if sct.Name == *gStructName {
			target = sct
			break
		}
	}
	if target == nil {
		return nil
	}

	if len(target.Columns) == 0 {
		panic(fmt.Sprintf("There is no fields in struct %s", target.Name))
	}

	// ast.Print(fset, f)
	tempData.StructName = target.Name
	tempData.PackageName = pkg.Name
	tempData.FileName = filename

	for _, field := range target.Columns {
		name := field.Name
		value := field.Name
		if len(*gTagName) != 0 {
			if len(field.Tag) == 0 {
				panic(fmt.Sprintf("Tag %s not found in struct %s", *gTagName, target.Name))
			}
			tag := handleTags(field.Tag)
			if len(tag) == 0 {
				panic(fmt.Sprintf("Tag %s value not found in struct %s", *gTagName, target.Name))
			}
			if strings.Contains(tag, ",") {
				tag = strings.Split(tag, ",")[0]
			}
			value = tag
		}
		tempData.Columns[name] = value
	}

	if *gDebug {
		//spew.Dump(tempData)
		tempData.writeTo(os.Stdout)
	}
	return tempData.WriteToFile()
}

func handleTags(tags string) string {
	re := regexp.MustCompile(fmt.Sprintf(`%s:"(.*?)"`, *gTagName))
	matchs := re.FindStringSubmatch(tags)
	if len(matchs) >= 1 {
		return matchs[1]
	}
	return ""
}

func (d *TempData) handleFilename() {
	absPath, _ := filepath.Abs(d.FileName)
	basePath := filepath.Dir(absPath)
	d.FileName = basePath + "/" + strings.ToLower(d.StructName) + gSuffix
	fmt.Println(d.FileName)
}

func (d *TempData) writeTo(w io.Writer) error {
	funcMap := template.FuncMap{
		"lower": strings.ToLower,
	}
	return template.Must(template.New("temp").Funcs(funcMap).Parse(temp)).Execute(w, d)
}

// WriteToFile 将生成好的模块文件写到本地
func (d *TempData) WriteToFile() error {
	d.handleFilename()
	file, err := os.Create(d.FileName)
	if err != nil {
		return err
	}
	defer file.Close()
	var buf bytes.Buffer
	_ = d.writeTo(&buf)
	formatted, _ := format.Source(buf.Bytes())
	file.Write(formatted)
	return err
}
