package main

import (
	"bytes"
	"flag"
	"fmt"
	"generator/common"
	"go/ast"
	"go/format"
	"io"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
)

var (
	gStructName     string
	gPath           string
	gCollectionName string
	gPackageName    string
)

const (
	gAutoGenSuffix = "_mgo" + common.AutoGeneratedSuffix
)

type StructTypeWrapper struct {
	Name       string
	StructType *ast.StructType
}

type Column struct {
	Name  string
	Value string
}

type CustomStruct struct {
	Name      string
	RawString string
}

type TemplateData struct {
	PackageName    string
	CollectionName string
	StructString   string
	CustomStructs  []CustomStruct
	Columns        []Column
	Folder         string
}

func main() {
	flag.StringVar(&gStructName, "type", "", "struct name")
	flag.StringVar(&gPath, "path", ".", "filepath")
	flag.StringVar(&gCollectionName, "c", "", "collection name")
	flag.StringVar(&gPackageName, "pkg", "", "package name, default is lowwer case of collection name without '-'")
	flag.Parse()
	if len(gStructName) == 0 {
		flag.Usage()
		panic("type must be set")
	}
	if len(gCollectionName) == 0 {
		flag.Usage()
		panic("collection name must be set")
	}
	// 推荐使用官方的命名方式, 简短而且不要有下划线什么的,如果不设置package name,那么就把 collection name
	// 全部小写而且去掉下划线和中划线什么的
	if len(gPackageName) == 0 {
		gPackageName = gCollectionName
	}
	reg := regexp.MustCompile("[^a-z0-9]")
	gPackageName = reg.ReplaceAllString(strings.ToLower(gPackageName), "")

	tplData := &TemplateData{
		PackageName:    gPackageName,
		CollectionName: gCollectionName,
	}

	var pkgFileName string
	var pkgfile *ast.File
	var sct *ast.StructType
	hasFound := false
	common.WalkPathWithGoExt(gPath, func(filename string) error {
		if hasFound {
			return nil
		}
		pkgfile = common.MustParseFile(filename)
		sct = common.GetStructByName(pkgfile, gStructName)
		if sct != nil {
			hasFound = true
			pkgFileName = filename
			return nil
		}
		return nil
	})
	if sct == nil {
		panic(fmt.Sprintf("Found no struct %s", gStructName))
	}

	if len(sct.Fields.List) == 0 {
		panic(fmt.Sprintf("There is field in struct ", gStructName))
	}

	tplData.Folder = path.Join(path.Dir(pkgFileName), gPackageName)
	tplData.StructString = string(common.GetRawBytesWithPosEnd(pkgFileName, sct.Pos(), sct.End()))

	columns, structs := getColumnsAndCustomStructs(pkgfile, sct, "")
	tplData.Columns = columns
	tplData.CustomStructs = getRawStructs(structs, pkgFileName)

	tplData.MustWriteToFile()
}

func parseBsonTagValue(tag, fieldName string) string {
	reg := regexp.MustCompile(`bson:"(.*)"`)
	ret := reg.FindAllStringSubmatch(tag, -1)

	// 如果解析不到用字段名字的小写模式
	value := strings.ToLower(fieldName)
	if len(ret) > 0 && len(ret[0]) > 1 {
		v := strings.Split(ret[0][1], ",")[0]
		if v == "-" {
			// 代表没有这个字段 `"bson:-"`
			return ""
		}
		if len(v) != 0 {
			value = v
		}
		// 没有解析到
	}

	return value
}

func (d *TemplateData) writeTo(w io.Writer) error {
	funcMap := template.FuncMap{
		"lower": strings.ToLower,
	}
	return template.Must(template.New("temp").Funcs(funcMap).Parse(MgoTemplate)).Execute(w, d)
}

func (d *TemplateData) MustWriteToFile() {
	if !common.ExistsDir(d.Folder) {
		os.MkdirAll(d.Folder, os.ModePerm)
	}
	filename := path.Join(d.Folder, d.PackageName+gAutoGenSuffix)
	file, err := os.Create(filename)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = d.writeTo(&buf)
	if err != nil {
		panic(err)
	}
	formatted, _ := format.Source(buf.Bytes())
	file.Write(formatted)
	file.Close()

	// format file
	common.MustFmtFile(filename)
	common.MustGoreturns(filename)
}

func getColumnsAndCustomStructs(file *ast.File, sct *ast.StructType, prefix string) ([]Column, []StructTypeWrapper) {
	if file == nil || sct == nil {
		return nil, nil
	}

	var customStructs []StructTypeWrapper
	var columns []Column
	for _, field := range sct.Fields.List {
		// 匿名函数，不支持的
		if _, ok := field.Type.(*ast.StructType); ok {
			panic("Anonymous struct is not supported")
		}

		name := field.Names[0].Name
		value := strings.ToLower(name)
		if field.Tag != nil {
			value = parseBsonTagValue(field.Tag.Value, name)
		}
		name = namePrefix(prefix, name)
		value = valuePrefix(prefix, value)

		hasBsonTag := len(value) > 0
		if hasBsonTag {
			columns = append(columns, Column{Name: name, Value: value})
		}

		sctname, scttype := verifyStructType(file, field)
		if scttype != nil {
			customStructs = append(customStructs, StructTypeWrapper{Name: sctname, StructType: scttype})

			clns, csts := getColumnsAndCustomStructs(file, scttype, name)
			if len(csts) > 0 {
				customStructs = append(customStructs, csts...)
			}
			if hasBsonTag && len(clns) > 0 {
				columns = append(columns, clns...)
			}
		}
	}
	return columns, customStructs
}

func namePrefix(prefix, name string) string {
	if len(prefix) > 0 {
		return prefix + "_" + name
	}
	return name
}

func valuePrefix(prefix, value string) string {
	if len(prefix) > 0 {
		return strings.ToLower(strings.Replace(prefix+"."+value, "_", ".", -1))
	}
	return value
}

func verifyStructType(file *ast.File, field *ast.Field) (string, *ast.StructType) {
	structsmap := common.GetAllStructMap(file)
	if structsmap == nil {
		return "", nil
	}
	if v, ok := field.Type.(*ast.Ident); ok {
		return v.Name, structsmap[v.Name]
	}
	return "", nil
}

func getRawStructs(structs []StructTypeWrapper, filename string) []CustomStruct {
	var res []CustomStruct
	for _, v := range structs {
		bytes := common.GetRawBytesWithPosEnd(filename, v.StructType.Pos(), v.StructType.End())
		res = append(res, CustomStruct{Name: v.Name, RawString: string(bytes)})
	}
	return res
}
